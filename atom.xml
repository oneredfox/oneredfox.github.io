<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘子兴的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://oneredfox.github.io/"/>
  <updated>2017-07-27T08:20:20.000Z</updated>
  <id>http://oneredfox.github.io/</id>
  
  <author>
    <name>刘子兴</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS-多线程-GCD-一</title>
    <link href="http://oneredfox.github.io/2016/06/01/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%B8%80/"/>
    <id>http://oneredfox.github.io/2016/06/01/iOS-多线程-GCD-一/</id>
    <published>2016-05-31T16:00:00.000Z</published>
    <updated>2017-07-27T08:20:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>　身为开发者的我们,总是会面临着各种各样的需求.必不可少的一个硬性规则:从用户体验的角度来开发项目!那么这就要求我们必须减少用户在使用程序中所需要等待的时间,看吧,多线程的概念出来了.</p>
<p>　我们经常在敲代码的时候边敲边听音乐,看看,这就是一个多线程的体现了(如果敲代码的时候不能进行其他的操作,我们会怎么想?).通过一张图我们来看一下实现进程的必要性吧.<br>　<br><img src="http://a2.qpic.cn/psb?/V11CFKUe0ogDzM/qQt*SHh0le4hVRTdaXOI7qDPn1116hxI.shNE5nPBPE!/b/dPcAAAAAAAAA&amp;bo=EASAAgAAAAADALM!&amp;rf=viewer_4" alt="进程的必要性"></p>
<p>　在iOS中,每启动一个进程都会创建一个主线程(一般用于刷新UI),这个线程是其他线程的父线程.由于在iOS中,除了主线程,其他的线程都是独立于Cocoa Touch的,所以只有主线程可以更新UI(不过现在好像其他线程也可能会成功,但是不推荐).常用的多线程开发主要有三种:<br>　<br>　1. <strong>NSThread</strong><br>　<br>　2. <strong>NSOperation</strong><br>　<br>　3. <strong>GCD</strong></p>
<p>　这三种是随着iOS的发展逐渐引进来的,所以靠后的使用相对来说越简单,而且GCD也是Apple官方主推荐的.在这里我们也只讨论GCD.<br>　<br>　GCD全称(Grand Central Dispatch),他是基于在C语言上的,抽象成都很高,使用也非常的简单.先说下GCD的优点吧.</p>
<p>　1. GCD是Apple官方为多核并发提供的解决方案<br>　<br>　2. GCD会自动利用CPU内核(不需要我们关心)<br>　<br>　3. GCD会自动管理线程的生命周期(不用我们手动管理)<br>　<br>　4. 总的来说就是我们只需要告诉GCD我们要执行什么任务,其他的都不用我们管理</p>
<p>注意:GCD是纯C语言的,我们在用GCD的时候,面对的是函数,而不是方法.</p>
<p> GCD中有两个核心的概念:</p>
<p>　1. <strong>任务</strong>(我们要执行什么样的操作)<br> 　<br>　2. <strong>队列</strong>(专门用于存放任务的)</p>
<p>　我们将任务添加到队列中,GCD会自动的将队列里的任务取出,放到对应的线程执行(FIFO).这几乎不用我们关心.<br>　<br>　GCD的任务分为两种:<br>　<br>　1. <strong>同步执行:dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)</strong><br>　<br>　      queue:队列<br>　<br>　      block:任务<br>　<br>　      把任务放进队列中执行<br>　<br>　2.  <strong>异步执行:dispatch_async(dispatch_queue_t queue, dispatch_block_t block)</strong><br>　<br> 　同步和异步的区别:<br> 　<br> 　<strong>同步</strong>:在当前线程中执行(不具备开线程的能力)<br> 　<br> 　<strong>异步</strong>:开辟新的线程执行任务(具备开线程能力,具体开几条暂时不说,下面会说)<br> 　<br> 　GCD的队列也有两种:<br> 　<br> 　1. <strong>串行队列</strong>:dispatch_queue_create(const char <em>label, dispatch_queue_attr_t attr);(主线程dispatch_get_main_queue(void)也是特殊的串行队列)<br> 　　第一个参数：队列名称<br> 　　<br> 　　第二个参数：队列类型<br> 　　<br> 　2. <strong>并发队列</strong>:也是使用dispatch_queue_create(const char </em>label, dispatch_queue_attr_t attr),不过系统已经为我们准备好了一个全局的并发队列dispatch_get_global_queue(long identifier, unsigned long flags),一般不需要我们去创建<br> 　<br> 　<br> 串行和并发的区别:  </p>
<p> <strong>串行</strong>:一个一个的执行任务,遵守FIFO(先进先出)规则  </p>
<p> <strong>并发</strong>:允许同时执行多个任务  </p>
<p> 注意:(<strong>dispatch_queue_attr_t attr</strong>决定着队列的类型<strong>DISPATCH_QUEUE_SERIAL(NULL)</strong>串行队列(其中串行队列的宏值为NULL,所以可以用NULL来创建,像这样:<strong>dispatch_queue_create(@”NICAI”, NULL)</strong>,代表的是串行队列),<strong>DISPATCH_QUEUE_CONCURRENT</strong>并发队列).  </p>
<p> 并发队列的优先级(long identifier):  </p>
<p> <strong>#define DISPATCH_QUEUE_PRIORITY_HIGH</strong> 2 // 高</p>
<p> <strong>#define DISPATCH_QUEUE_PRIORITY_DEFAULT</strong> 0 // 默认（中）</p>
<p> <strong>#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</strong> // 低</p>
<p> <strong>#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</strong> // 后台  </p>
<p> 有很多人会混淆串行,并发,异步,同步的概念.当然,他们是单独开辟线程执行任务,还是唯一线程执行任务,并不绝对.例如:在串行异步,并不会开开辟新的线程.看图:1.2  </p>
<p> <img src="http://a2.qpic.cn/psb?/V11CFKUe0ogDzM/0kkBbgSwWyr1.*CaWRLYHaBS4f*YxlZlRBrNbhZpYFE!/b/dB4BAAAAAAAA&amp;bo=2ARkAQAAAAADAJw!&amp;rf=viewer_4" alt="图1.2">  </p>
<p> 从上面我们可以得出几个规律:  </p>
<p> 1.同步任务不会开辟新的线程(不管是串行队列还是并发队列)</p>
<p> 2.异步任务只有在主线程的时候不会开辟新的线程,其他的都会开辟</p>
<p> 3.并发队列只有在异步的时候才会并发的执行任务(也就是开多条线程,具体数量受系统控制,主线程除外)  </p>
<p> 下面我们用代码来一一验证:  </p>
<p> 1.<strong>全局队列异步执行:</strong>(1.3,1.4)  </p>
<p> <img src="http://a1.qpic.cn/psb?/V11CFKUe0ogDzM/pjn*l4MsEEVYaAQ*SgL7nICBck51miu3MBYcvNqmjt8!/b/dHUAAAAAAAAA&amp;bo=2AQ2AgAAAAADAM0!&amp;rf=viewer_4" alt="1.3"><br> <img src="http://a2.qpic.cn/psb?/V11CFKUe0ogDzM/Ej4gvd6Q9dGh9IPqzbQA7kif.v7zwERNa6OWYyWe3TE!/b/dB4BAAAAAAAA&amp;bo=2AR2AAAAAAARAJ0!&amp;rf=viewer_4" alt="1.4"> </p>
<p> 结论:<strong>全局队列异步执行同时开启了三个线程(number分别为3,4,2,)并发的执行(并不是按照FIFO打印出1,2,3)[第一个红色的框里面是项目中打印出来的数字,第二个红色框里面number代表着线程的数量,创建的时候是累加,name代表着线程的名字]</strong>  </p>
<p> 2.<strong>全局队列同步执行:</strong>(2.1,2.2) </p>
<p> <img src="http://a1.qpic.cn/psb?/V11CFKUe0ogDzM/*sysy0PKstI13BUCoz9L.u2ay0tVjF99hOGX8YDwb7s!/b/dHUAAAAAAAAA&amp;bo=2AQGAgAAAAADAP0!&amp;rf=viewer_4" alt="2.1"><br> <img src="http://a3.qpic.cn/psb?/V11CFKUe0ogDzM/t6BYIf8LluY5soridC*GDn1jAeTxqObqTZdxygmKvaM!/b/dAEBAAAAAAAA&amp;bo=2ARlAAAAAAARAI4!&amp;rf=viewer_4" alt="2.2">  </p>
<p> 结论:<strong>全局队列同步执行没有开启新的线程,在主线程执行任务</strong>  </p>
<p> 3.<strong>串行队列同步执行:</strong>(3.1,.3.2)<br> <img src="http://a2.qpic.cn/psb?/V11CFKUe0ogDzM/TPEq94T3*xgmZR*rSj1t728TzT.ZC4yWP0E2YCXHENw!/b/dB4BAAAAAAAA&amp;bo=2AQKAgAAAAADAPE!&amp;rf=viewer_4" alt="3.1"><br> <img src="http://a2.qpic.cn/psb?/V11CFKUe0ogDzM/T1B*x6mNUC03fIDJItiL1NI87zTNqzkTK7psdhGDrVM!/b/dB4BAAAAAAAA&amp;bo=2ARfAAAAAAARALQ!&amp;rf=viewer_4" alt="3.2">  </p>
<p> 结论:<strong>串行队列同步执行并不会创建新的线程,在主线程中执行</strong>  </p>
<p> 4.串行队列异步执行:(4.1,.4.2)<br> <img src="http://a2.qpic.cn/psb?/V11CFKUe0ogDzM/kTDybryLH.oC2*EARYtDVYHUgdetvc1Ql.T7r6p1jio!/b/dB4BAAAAAAAA&amp;bo=2AQRAgAAAAADAOo!&amp;rf=viewer_4" alt="4.1"><br> <img src="http://a2.qpic.cn/psb?/V11CFKUe0ogDzM/yyrMB.ric6jfKYjCRrJ1vLrSYD3ttMFWNwuMT57Riss!/b/dB4BAAAAAAAA&amp;bo=2ARuAAAAAAARAIU!&amp;rf=viewer_4" alt="4.2">  </p>
<p> 结论:<strong>串行队列异步执行会开辟新的线程,但只开辟了一个</strong>  </p>
<p> 最后在总结一下:  </p>
<p> 　1.在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并行队列并且使用异步方法执行时才能在多个线程中执行。</p>
<p>　2.串行队列可以按顺序执行，并行队列的异步方法无法确定执行顺序。</p>
<p>　3.UI界面的更新最好采用同步方法，其他操作采用异步方法。</p>
<p>　GCD执行任务的方法并非只有简单的同步调用方法和异步调用方法，还有其他一些常用方法:<br> 　<br>　<strong>dispatch_apply()</strong>:重复执行某个任务，但是注意这个方法没有办法异步执行(为了不阻塞线程可以使用<strong>dispatch_async()</strong>包装一下再执行).</p>
<p>　<strong>dispatch_once()</strong>:单次执行一个任务，此方法中的任务只会执行一次，重复调用也没办法重复执行(单例模式中常用此方法).</p>
<p>　<strong>dispatch_time()</strong>：延迟一定的时间后执行.</p>
<p>　<strong>dispatch_barrier_async()</strong>：使用此方法创建的任务首先会查看队列中有没有别的任务要执行，如果有，则会等待已有任务执行完毕再执行；同时在此方法后添加的任务必须等待此方法中任务执行后才能执行。（利用这个方法可以  控制执行顺）</p>
<p>　<strong>dispatch_group_async()</strong>：实现对任务分组管理，如果一组任务全部完成可以通过<strong>dispatch_group_notify()</strong>方法获得完成通知(需要定义<strong>dispatch_group_t</strong>作为分组标识).<br>　<br><img src="http://a3.qpic.cn/psb?/V11CFKUe0ogDzM/w0hdkS02ZOCGvasjJiL9gztK2pvVaHa8wP6Bybzl6yA!/b/dLMAAAAAAAAA&amp;bo=2ARlAgAAAAADAJ4!&amp;rf=viewer_4" alt="dispatch_group_async"><br><img src="http://a3.qpic.cn/psb?/V11CFKUe0ogDzM/xPDAOEDeeVodRdXC9xHRIWrVKij2ugayyRBsABZCLhI!/b/dLMAAAAAAAAA&amp;bo=9gOEAAAAAAADAFQ!&amp;rf=viewer_4" alt="dispatch_group_notify"></p>
<p>　<a href="https://github.com/oneredfox/GCDdemo" target="_blank" rel="external">demo</a></p>
<p> 　
　
　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　身为开发者的我们,总是会面临着各种各样的需求.必不可少的一个硬性规则:从用户体验的角度来开发项目!那么这就要求我们必须减少用户在使用程序中所需要等待的时间,看吧,多线程的概念出来了.&lt;/p&gt;
&lt;p&gt;　我们经常在敲代码的时候边敲边听音乐,看看,这就是一个多线程的体现了(如果
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>NSCache</title>
    <link href="http://oneredfox.github.io/2016/04/21/NSCache/"/>
    <id>http://oneredfox.github.io/2016/04/21/NSCache/</id>
    <published>2016-04-21T14:55:08.000Z</published>
    <updated>2017-07-27T02:20:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NSCache-基本介绍"><a href="#NSCache-基本介绍" class="headerlink" title="NSCache 基本介绍"></a>NSCache 基本介绍</h1><p><code>NSCache</code>是苹果官方提供的缓存类,它的用法和<code>NSMutableDictionary</code>非常类似.</p>
<p><code>NSCache</code>是一个类似于集合的容器,即缓存.它存储key-value,这一点非常类似<code>NSDictionary</code>. 开发者一般用<code>NSCache</code>来缓存临时存储短时间但是使用创建成本高的对象,重用这些对象可以优化性能,因为他们的值不需要被重新计算.另外一方面,这些对象对于程序来说是不要紧的,在内存紧张的时候会被丢弃,如果对象被丢弃了,则下次使用的时候需要重新计算.</p>
<p>当一个key-value对在缓存时,缓存维护它的一个强引用.存储在<code>NSCache</code>中的通用数据类型通常是实现了<code>NSDiscardableContent</code>协议的对象.在缓存中存储这类对象的好处是,当你不需要它的时候可以丢弃这些内容,以节省内存.默认情况下,缓存中的<code>NSDiscardableContent</code>对象在其内容被丢弃的时候,会被移除缓存,如果一个<code>NSDiscardableContent</code>被放进缓存，则在对象被移除时，缓存会调用<code>discardContentIfPossible</code>方法。</p>
<p><code>NSCache</code>与可变集合的不同:   </p>
<ol>
<li><code>NSCache</code>类结合了各种自动删除策略，以确保不会占用过多的系统内存。如果其它应用需要内存时，系统自动执行这些策略。当调用这些策略时，会从缓存中删除一些对象，以最大限度减少内存的占用</li>
<li><code>NSCache</code>是线程安全的，我们可以在不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域</li>
<li>不像<code>NSMutableDictionary</code>对象，一个缓存对象不会拷贝key对象</li>
</ol>
<h2 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h2><p>@property NSUInteger countLimit 缓存应持有的对象的最大数量。</p>
<pre><code>This is not a strict limit—if the cache goes over the limit, an object in the cache could be evicted instantly, later, or possibly never, depending on the implementation details of the cache. 
这不是一个严格的限制。如果缓存的数量超过这个数量，缓存中的一个对象可能会被立即丢弃、或者稍后、也可能永远不会，具体依赖于缓存的实现细节。
</code></pre><p>@property NSUInteger totalCostLimit  </p>
<pre><code>limits are imprecise/not strict
来限定缓存能维持的最大内存,但totalCostLimit也不是一个严格限制
</code></pre><p>@property BOOL evictsObjectsWithDiscardedContent;</p>
<pre><code>是否自动清理缓存,默认是YES
</code></pre><h2 id="存取方法介绍"><a href="#存取方法介绍" class="headerlink" title="存取方法介绍"></a>存取方法介绍</h2><pre><code>- setObject:forKey:
- setObject:forKey:cost:
- removeObjectForKey:
- removeAllObjects
</code></pre><h2 id="NSCacheDelegate"><a href="#NSCacheDelegate" class="headerlink" title="NSCacheDelegate"></a>NSCacheDelegate</h2><pre><code>- (void)cache:(NSCache *)cachewillEvictObject:(id)obj
</code></pre><p> 缓存将要删除对象时调用，不能在此方法中修改缓存</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NSCache-基本介绍&quot;&gt;&lt;a href=&quot;#NSCache-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;NSCache 基本介绍&quot;&gt;&lt;/a&gt;NSCache 基本介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;NSCache&lt;/code&gt;是苹果官方提供的缓存
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>iOS-多线程-GCD-二</title>
    <link href="http://oneredfox.github.io/2016/04/11/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%BA%8C/"/>
    <id>http://oneredfox.github.io/2016/04/11/iOS-多线程-GCD-二/</id>
    <published>2016-04-10T16:00:00.000Z</published>
    <updated>2017-07-27T08:19:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近总是忙着忙那,好久没动过笔了<br>　<br>　<strong>dispatch_semaphore_create</strong>,dispatch_semaphore_wait,dispatch_semaphore_signal<strong>在多线程中控制多线程的并发数目,也可以达到线程锁的功效,先大致的说下他们每个的作用.  
　    
　</strong>dispatch_semaphore_create(long value)**:代表信号总量(信号就是你想每次执行几个任务)</p>
<p>　<strong>dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)</strong>:等待信号,可以设置超时参数.如果信号量&gt;0,那么会继续执行,并且总的信号量-1;如果信号量=0,则会阻塞当前的线程</p>
<p>　<strong>dispatch_semaphore_signal(dispatch_semaphore_t dsema)</strong>:通知信号，如果等待线程被唤醒则返回非0,否则返回0.并且会让信号总量+1.</p>
<p>　下面说说用法<br>　<br>　<strong>一.比如我现在想执行10个任务,休息两秒后呢,继续执行10各任务,再休息两秒,在执行…可以这么做(如图1.1):</strong><br>　<img src="http://a3.qpic.cn/psb?/V11CFKUe0ogDzM/Z10dS.*IHAwl9F1TW1Twg6olFwcWRQScu7cje7kEI14!/b/dLMAAAAAAAAA&amp;bo=2AT5AQAAAAADBwY!&amp;rf=viewer_4" alt="1.1"><br>　<br>　简单解释下上面图片中代码的意思:创建了一个初使值为3的semaphore,每一次for循环都会创建一个新的线程,线程结束的时候会发送一个信号,线程创建之前会信号等待,所以当同时创建了10个线程之后,for循环就会阻塞,等待有线程结束之后会增加一个信号才继续执行,如此就形成了对并发的控制,如上就是一个并发数为3的一个线程队列.<br>　<br>　<strong>二:生产者—消费者模式</strong><br>　<br>　如图2.2<br>　<br>　<img src="http://a3.qpic.cn/psb?/V11CFKUe0ogDzM/Xt965aVBNHZlZQSYFgP5RQC9ncm2eWSOLRZoQ7gXsDI!/b/dBkBAAAAAAAA&amp;bo=YQSAAgAAAAADAMI!&amp;rf=viewer_4" alt="2.2"><br>　<br>　简单说下上面代码:创建了两个并发队列,semaphore初始值设为1,两个队列的执行情况:1.生产队列执行到if时候,信号总量变为1,并生产了第一个蛋糕,并睡两秒,2.消费者队列执行到等待信号的时候,信号总量0,阻塞当前线程,一直等到消费者队列执行完通知信号是,信号总量变为1,继续执行,拿到了蛋糕,信号总量再次变为0.<br>　<br>　<strong>三:应用简单示例:同步下载9张图片,下载完一张显示一张(线程锁的功能)</strong></p>
<p>　代码下面会附上demo,简单说下实现:首先把信号总量设为1,并创建了9个线程,每个线程负责现在一张图片,下载图片的时候开启等待信号,下载完成后更新界面,并发送通知信号  </p>
<p>　<a href="https://github.com/oneredfox/GCDdemo" target="_blank" rel="external">最后附上demo</a>
　
　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近总是忙着忙那,好久没动过笔了&lt;br&gt;　&lt;br&gt;　&lt;strong&gt;dispatch_semaphore_create&lt;/strong&gt;,dispatch_semaphore_wait,dispatch_semaphore_signal&lt;strong&gt;在多线程中控制多线程的
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>日常总结</title>
    <link href="http://oneredfox.github.io/2015/04/20/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    <id>http://oneredfox.github.io/2015/04/20/日常总结/</id>
    <published>2015-04-20T14:55:08.000Z</published>
    <updated>2017-07-20T03:19:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-我们有时候需要将一个Core-Foundation对象转换成一个Objective-C对象-这个时候我们需要告诉编译器-转换过程中引用计数如何调整-这时候就引入了与bridge相关的关键字"><a href="#一-我们有时候需要将一个Core-Foundation对象转换成一个Objective-C对象-这个时候我们需要告诉编译器-转换过程中引用计数如何调整-这时候就引入了与bridge相关的关键字" class="headerlink" title="一:我们有时候需要将一个Core Foundation对象转换成一个Objective-C对象,这个时候我们需要告诉编译器,转换过程中引用计数如何调整,这时候就引入了与bridge相关的关键字,"></a>一:我们有时候需要将一个Core Foundation对象转换成一个Objective-C对象,这个时候我们需要告诉编译器,转换过程中引用计数如何调整,这时候就引入了与bridge相关的关键字,</h3><ol>
<li>__bridge:只做类型转换,不修改相关对象的引用技术,原来的Core Foundation对象在不用时,需要调用CFRelease方法;</li>
<li>__bridge_retailned:类型转换后,将先关对象的引用技术加1,原来的Core Foundation对象不用时,需要调用CFRelease方法;</li>
<li>__bridge_transfer:类型转换后,将该对象的引用计数交给arc管理,原来的Core Foundation对象在不用时,不需要调用CFRelease方法.</li>
</ol>
<h3 id="二-UIWindow有个属性WindowLevel-该属性蒂尼了UIWindow的层级-系统定义的WindowLevel一共有3种取值-如下所示"><a href="#二-UIWindow有个属性WindowLevel-该属性蒂尼了UIWindow的层级-系统定义的WindowLevel一共有3种取值-如下所示" class="headerlink" title="二:UIWindow有个属性WindowLevel,该属性蒂尼了UIWindow的层级,系统定义的WindowLevel一共有3种取值,如下所示:"></a>二:UIWindow有个属性WindowLevel,该属性蒂尼了UIWindow的层级,系统定义的WindowLevel一共有3种取值,如下所示:</h3><pre><code>UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal;
UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert;
UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar;
</code></pre><p>   程序默认热UIWindow的层级是UIWindowLevelNormal,当系统需要在上面覆盖UIAlertContronler时,就会创建一个层级是UIWindowLevelAlert的UIWindow,因为其WindowLevel值更高,所以覆盖在上面了.<br>   需要注意的是:在实际应用中,WindowLevel并不仅限于上面三个值.</p>
<h3 id="三-UITableView的plain样式下，取消区头停滞效果"><a href="#三-UITableView的plain样式下，取消区头停滞效果" class="headerlink" title="三:UITableView的plain样式下，取消区头停滞效果"></a>三:UITableView的plain样式下，取消区头停滞效果</h3><pre><code> - (void)scrollViewDidScroll:(UIScrollView*)scrollView
{
    CGFloat sectionHeaderHeight = sectionHead.height;
    if (scrollView.contentOffset.y=0) {
         scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);
    } else if (scrollView.contentOffset.y&gt;=sectionHeaderHeight) {
      scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);
    }
}
</code></pre><p>其实就是group样式</p>
<h3 id="四-获取汉语的拼音"><a href="#四-获取汉语的拼音" class="headerlink" title="四:获取汉语的拼音"></a>四:获取汉语的拼音</h3><pre><code>+ (NSString *)transform:(NSString *)chinese
{    
   //将NSString装换成NSMutableString 
   NSMutableString *pinyin = [chinese mutableCopy];    
   //将汉字转换为拼音(带音标)    
   CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);    
   NSLog(@&quot;%@&quot;, pinyin);    
   //去掉拼音的音标    
  CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);    
   NSLog(@&quot;%@&quot;, pinyin);    
   //返回最近结果    
   return pinyin;
 }  
</code></pre><h3 id="五-NSArray-快速求总和-最大值-最小值-和-平均值"><a href="#五-NSArray-快速求总和-最大值-最小值-和-平均值" class="headerlink" title="五:NSArray 快速求总和 最大值 最小值 和 平均值"></a>五:NSArray 快速求总和 最大值 最小值 和 平均值</h3><pre><code>NSArray *array = [NSArray arrayWithObjects:@&quot;2.0&quot;, @&quot;2.3&quot;, @&quot;3.0&quot;, @&quot;4.0&quot;, @&quot;10&quot;, nil];
//和
CGFloat sum = [[array valueForKeyPath:@&quot;@sum.floatValue&quot;] floatValue];
//平均值
CGFloat avg = [[array valueForKeyPath:@&quot;@avg.floatValue&quot;] floatValue];
//最大值
CGFloat max =[[array valueForKeyPath:@&quot;@max.floatValue&quot;] floatValue];
//最小值
CGFloat min =[[array valueForKeyPath:@&quot;@min.floatValue&quot;] floatValue];
NSLog(@&quot;%f\n%f\n%f\n%f&quot;,sum,avg,max,min);
</code></pre><h3 id="六-修改UITextField中Placeholder的文字颜色"><a href="#六-修改UITextField中Placeholder的文字颜色" class="headerlink" title="六:修改UITextField中Placeholder的文字颜色"></a>六:修改UITextField中Placeholder的文字颜色</h3><pre><code> //方法一:
[textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];
[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@&quot;_placeholderLabel.font&quot;];

方法二:
NSString *string = @&quot;美丽新世界&quot;;
NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:string];

[attributedString addAttribute:NSForegroundColorAttributeName
                         value:[UIColor redColor]
                         range:NSMakeRange(0, [string length])];

[attributedString addAttribute:NSFontAttributeName
                         value:[UIFont systemFontOfSize:16]
                         range:NSMakeRange(0, [string length])];

self.textField.attributedPlaceholder = attributedString;
</code></pre><h3 id="七-取消UICollectionView的隐式动画"><a href="#七-取消UICollectionView的隐式动画" class="headerlink" title="七:取消UICollectionView的隐式动画"></a>七:取消UICollectionView的隐式动画</h3><p>   UICollectionView在reloadItems的时候，默认会附加一个隐式的fade动画，有时候很讨厌，尤其是当你的cell是复合cell的情况下(比如cell使用到了UIStackView)。</p>
<pre><code>//方法一
[UIView performWithoutAnimation:^{
   [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
}];

//方法二
[UIView animateWithDuration:0 animations:^{
   [collectionView performBatchUpdates:^{
   [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
} completion:nil];
}];

//方法三
[UIView setAnimationsEnabled:NO];
[self.trackPanel performBatchUpdates:^{
   [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
} completion:^(BOOL finished) {
   [UIView setAnimationsEnabled:YES];
}];
</code></pre><h3 id="八-图片上绘制文字"><a href="#八-图片上绘制文字" class="headerlink" title="八:图片上绘制文字"></a>八:图片上绘制文字</h3><pre><code>- (UIImage *)imageWithTitle:(NSString *)title fontSize:(CGFloat)fontSize
{
//画布大小
CGSize size=CGSizeMake(self.size.width,self.size.height);
//创建一个基于位图的上下文
UIGraphicsBeginImageContextWithOptions(size,NO,0.0);//opaque:NO  scale:0.0

[self drawAtPoint:CGPointMake(0.0,0.0)];

//文字居中显示在画布上
NSMutableParagraphStyle* paragraphStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy];
paragraphStyle.lineBreakMode = NSLineBreakByCharWrapping;
paragraphStyle.alignment=NSTextAlignmentCenter;//文字居中

//计算文字所占的size,文字居中显示在画布上
CGSize sizeText=[title boundingRectWithSize:self.size options:NSStringDrawingUsesLineFragmentOrigin
                                 attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:fontSize]}context:nil].size;
CGFloat width = self.size.width;
CGFloat height = self.size.height;

CGRect rect = CGRectMake((width-sizeText.width)/2, (height-sizeText.height)/2, sizeText.width, sizeText.height);
//绘制文字
[title drawInRect:rect withAttributes:@{ NSFontAttributeName:[UIFont systemFontOfSize:fontSize],NSForegroundColorAttributeName:[ UIColor whiteColor],NSParagraphStyleAttributeName:paragraphStyle}];

//返回绘制的新图形
UIImage *newImage= UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
return newImage;
}
</code></pre><h3 id="九-UIView设置部分圆角"><a href="#九-UIView设置部分圆角" class="headerlink" title="九:UIView设置部分圆角"></a>九:UIView设置部分圆角</h3><pre><code>- (void)setCornerWithTopLeft:(BOOL)topLeft topRight:(BOOL)topRight bottomLeft:(BOOL)bottomLeft bottomRight:(BOOL)bottomRight andSize:(CGSize)size {

   CGRect rect = self.bounds;
   UIRectCorner corner;
   if (topLeft) {
       corner = corner | UIRectCornerTopLeft;
   };
   if (topRight) {
       corner = corner | UIRectCornerTopRight;
   };
   if (bottomLeft) {
       corner = corner | UIRectCornerBottomLeft;
   };
   if (bottomRight) {
       corner = corner | UIRectCornerBottomRight;
   };

   UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corner cornerRadii:size];
   CAShapeLayer *masklayer = [[CAShapeLayer alloc]init];//创建shapelayer
   masklayer.frame = self.bounds;
   masklayer.path = path.CGPath;//设置路径
  self.layer.mask = masklayer;
}
</code></pre><h3 id="十-给UIView设置图片"><a href="#十-给UIView设置图片" class="headerlink" title="十:给UIView设置图片"></a>十:给UIView设置图片</h3><pre><code>UIImage *image = [UIImage imageNamed:@&quot;image&quot;];
View.layer.contents = (__bridge id _Nullable)(image.CGImage);
View.layer.contentsRect = CGRectMake(0, 0, 0.5, 0.5);
</code></pre><h3 id="十一-防止scrollView手势覆盖侧滑手势"><a href="#十一-防止scrollView手势覆盖侧滑手势" class="headerlink" title="十一:防止scrollView手势覆盖侧滑手势"></a>十一:防止scrollView手势覆盖侧滑手势</h3><pre><code>[scrollView.panGestureRecognizerrequireGestureRecognizerToFail:self.navigationController.interactivePopGestureRecognizer];
</code></pre><h3 id="十一-检查字符串中是否含有中文-NSString-Extension"><a href="#十一-检查字符串中是否含有中文-NSString-Extension" class="headerlink" title="十一:检查字符串中是否含有中文(NSString+Extension)"></a>十一:检查字符串中是否含有中文(NSString+Extension)</h3><pre><code>- (BOOL)checkIsChinese {
   for(int i=0; i&lt; [self length]; i++){
       int a = [self characterAtIndex:i];
       if( a &gt; 0x4e00 &amp;&amp; a &lt; 0x9fff) {
          return YES;
       } 
    }
   return NO;
}
</code></pre><h3 id="十二-UITextField每四位加一个空格-实现代理"><a href="#十二-UITextField每四位加一个空格-实现代理" class="headerlink" title="十二:UITextField每四位加一个空格,实现代理"></a>十二:UITextField每四位加一个空格,实现代理</h3><pre><code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {
   // 四位加一个空格
   if ([string isEqualToString:@&quot;&quot;]) {
       // 删除字符
       if ((textField.text.length - 2) % 5 == 0) {
           textField.text = [textField.text substringToIndex:textField.text.length - 1];
       }
       return YES;
   } else {
       if (textField.text.length % 5 == 0) {
           textField.text = [NSString stringWithFormat:@&quot;%@ &quot;, textField.text];
       }
   }
   return YES;
}
</code></pre><h3 id="十三-屏蔽触发事件，2秒后取消屏蔽"><a href="#十三-屏蔽触发事件，2秒后取消屏蔽" class="headerlink" title="十三:屏蔽触发事件，2秒后取消屏蔽"></a>十三:屏蔽触发事件，2秒后取消屏蔽</h3><pre><code>[[UIApplication sharedApplication] beginIgnoringInteractionEvents];
   dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
   [[UIApplication sharedApplication] endIgnoringInteractionEvents]
</code></pre><p>   });</p>
<h3 id="十四-两点之间的距离"><a href="#十四-两点之间的距离" class="headerlink" title="十四:两点之间的距离"></a>十四:两点之间的距离</h3><pre><code>static __inline__ CGFloat CGPointDistanceBetweenTwoPoints(CGPoint point1, CGPoint point2) { CGFloat dx = point2.x - point1.x; CGFloat dy = point2.y - point1.y; return sqrt(dx*dx + dy*dy);}
</code></pre><h3 id="十五-使用UIScrollViewKeyboardDismissMode实现了Message-app的行为"><a href="#十五-使用UIScrollViewKeyboardDismissMode实现了Message-app的行为" class="headerlink" title="十五:使用UIScrollViewKeyboardDismissMode实现了Message app的行为"></a>十五:使用UIScrollViewKeyboardDismissMode实现了Message app的行为</h3><pre><code>UIScrollView有一个很好用的属性keyboardDismissMode,把它设置成UIScrollViewKeyboardDismissModeOnDrag,可以控制键盘在scrollview滚动的时候消失
</code></pre><p>这个属性使用了新的UIScrollViewKeyboardDismissMode enum枚举类型。这个enum枚举类型可能的值如下：</p>
<pre><code>typedef NS_ENUM(NSInteger, UIScrollViewKeyboardDismissMode) {
UIScrollViewKeyboardDismissModeNone,
UIScrollViewKeyboardDismissModeOnDrag,      // dismisses the keyboard when a drag begins
UIScrollViewKeyboardDismissModeInteractive, // the keyboard follows the dragging touch off screen, and may be pulled upward again to cancel the dismiss
} NS_ENUM_AVAILABLE_IOS(7_0);
</code></pre><h3 id="十六-获得当前硬盘空间"><a href="#十六-获得当前硬盘空间" class="headerlink" title="十六:获得当前硬盘空间"></a>十六:获得当前硬盘空间</h3><pre><code>NSFileManager *fm = [NSFileManager defaultManager];
NSDictionary *fattributes = [fm attributesOfFileSystemForPath:NSHomeDirectory() error:nil];

NSLog(@&quot;容量%lldG&quot;,[[fattributes objectForKey:NSFileSystemSize] longLongValue]/1000000000);
NSLog(@&quot;可用%lldG&quot;,[[fattributes objectForKey:NSFileSystemFreeSize] longLongValue]/1000000000);
</code></pre><h3 id="十七-给UIView-设置透明度，不影响其他sub-views"><a href="#十七-给UIView-设置透明度，不影响其他sub-views" class="headerlink" title="十七:给UIView 设置透明度，不影响其他sub views"></a>十七:给UIView 设置透明度，不影响其他sub views</h3><p>UIView设置了alpha值，但其中的内容也跟着变透明,如果想不影响其他内容的aopha,可以设置color的alpha.<br>eg:    </p>
<pre><code>[view.backgroundColor colorWithAlphaComponent:0.5];
</code></pre><h3 id="十八-ActivityViewController-使用AirDrop分享"><a href="#十八-ActivityViewController-使用AirDrop分享" class="headerlink" title="十八:ActivityViewController 使用AirDrop分享"></a>十八:ActivityViewController 使用AirDrop分享</h3><pre><code>NSArray *array = @[@&quot;test1&quot;, @&quot;test2&quot;];

UIActivityViewController *activityVC = [[UIActivityViewController alloc] initWithActivityItems:array applicationActivities:nil];

[self presentViewController:activityVC animated:YES
             completion:^{
                 NSLog(@&quot;Air&quot;);
}];
</code></pre><h3 id="十九-APP-屏蔽-触发事件"><a href="#十九-APP-屏蔽-触发事件" class="headerlink" title="十九:APP 屏蔽 触发事件"></a>十九:APP 屏蔽 触发事件</h3><pre><code>[[UIApplication sharedApplication] beginIgnoringInteractionEvents];
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-我们有时候需要将一个Core-Foundation对象转换成一个Objective-C对象-这个时候我们需要告诉编译器-转换过程中引用计数如何调整-这时候就引入了与bridge相关的关键字&quot;&gt;&lt;a href=&quot;#一-我们有时候需要将一个Core-Foundat
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>NS_OPTIONS与NS_ENUM的区别</title>
    <link href="http://oneredfox.github.io/2014/07/20/NS_OPTIONS%E4%B8%8ENS_ENUM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://oneredfox.github.io/2014/07/20/NS_OPTIONS与NS_ENUM的区别/</id>
    <published>2014-07-20T14:55:08.000Z</published>
    <updated>2017-07-27T02:20:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="NS-OPTIONS"><a href="#NS-OPTIONS" class="headerlink" title="NS_OPTIONS"></a>NS_OPTIONS</h3><pre><code>typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) { 
    SDWebImageRetryFailed = 1 &lt;&lt; 0, //值为2的0次方
    SDWebImageLowPriority = 1 &lt;&lt; 1, //值为2的1次方 
    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, //值为2的2次方 
    SDWebImageProgressiveDownload = 1 &lt;&lt; 3, //值为2的3次方     
    SDWebImageRefreshCached = 1 &lt;&lt; 4 //值为2的4次方 
};
</code></pre><blockquote>
<p>小括号中第一个为NSUInteger这个为固定值，第二个为枚举名字(自己定义),大括号中枚举项必须全部包含小括号的枚举类型，枚举项后面再跟上几个值的区别，这里枚举项是NSUInteger类型</p>
</blockquote>
<h3 id="NS-ENUM"><a href="#NS-ENUM" class="headerlink" title="NS_ENUM"></a>NS_ENUM</h3><pre><code>typedef NS_ENUM(NSInteger, SDWebImageOptions {
     SDWebImageRetryFailed = 0, //值为0            SDWebImageLowPriority = 1, //值为1        SDWebImageCacheMemoryOnly = 2 //值为2       
};
</code></pre><blockquote>
<p>小括号中第一个为NSInteger这个为固定值，第二个为枚举名称(自己定义)，大括号中枚举项必须包含小括号中自己定义的枚举类型，枚举项自己加后缀以视区别，大括号中的枚举项的值可自定义，若是定义了枚举项其中一项的值后面依次在它的前一项的值上加1，如这样：</p>
</blockquote>
<pre><code>typedef NS_ENUM(NSInteger, SDWebImageOptions) {
    SDWebImageRetryFailed = 0, //值为0            SDWebImageLowPriority, //值为1             SDWebImageCacheMemoryOnly //值为2      
 }; 
</code></pre><p>//或者这样 </p>
<pre><code>typedef NS_ENUM(NSInteger,SDWebImageOptions) {
    SDWebImageRetryFailed = 0, //值为0            SDWebImageLowPriority = 2, //值为2         SDWebImageCacheMemoryOnly //值为3    
};
</code></pre><p>//若是都不定义值，默认第一项为0，后面依次枚举项的值加1。</p>
<p>当然也可以下方这样写枚举，但是官方不推荐:</p>
<pre><code>typedef enum { 
    SDWebImageRetryFailed = 0,                 SDWebImageLowPriority = 1,
     SDWebImageCacheMemoryOnly = 2  
} SDWebImageOptions;
</code></pre><h3 id="NS-ENUM与NS-OPTIONS的区别"><a href="#NS-ENUM与NS-OPTIONS的区别" class="headerlink" title="NS_ENUM与NS_OPTIONS的区别"></a>NS_ENUM与NS_OPTIONS的区别</h3><ul>
<li><p>NS_ENUM枚举项的值为NSInteger，NS_OPTIONS枚举项的值为NSUInteger;</p>
<blockquote>
<p>这里为什么NS_ENUM用NSInteger，NS_OPTIONS用NSUInteger看后  面总结</p>
</blockquote>
</li>
<li><p>NS_ENUM定义通用枚举，NS_OPTIONS定义位移枚举</p>
<blockquote>
<p>位移枚举即是在你需要的地方可以同时存在多个枚举值如这样：</p>
</blockquote>
<pre><code>UISwipeGestureRecognizer *swipeGR = [[UISwipeGestureRecognizer alloc] init];
swipeGR.direction = UISwipeGestureRecognizerDirectionDown | UISwipeGestureRecognizerDirectionLeft | UISwipeGestureRecognizerDirectionRight;
</code></pre><blockquote>
<p>而NS_ENUM定义的枚举不能几个枚举项同时存在，只能选择其中一项，像这样：</p>
</blockquote>
<pre><code>   UITextField *textfiled =[[UITextField alloc]init];
textfiled.keyboardType = UIKeyboardTypeDefault;
</code></pre></li>
<li><p>NS_OPTIONS的枚举项的值需要像这样表示1 &lt;&lt; 0，1 &lt;&lt; 1，2的几次方这样，而NS_ENUM可以直接给像1，2，3这样。</p>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>  这里为什么会出现NS_OPTIONS与NS_ENUM且为什么不直接一个就行，且枚举值可多选。因为有个是否将代码按照C++模式编译，若是不按照C++模式编译，NS_OPTIONS与NS_ENUM展开方式就一样，若是要按照C++模式编译，就不同了。在使用或运算操作两个枚举值时，C++默认为运算结果的数据类型是枚举的底层数据类型即NSUInteger,且C++不允许它隐式转换为枚举类型本身，所以C++模式下定义了NS_OPTIONS宏以保证不出现类型转换。<br>到了这我们就知道了只要枚举值需要用到按位或（2个及以上枚举值可多个存在）就使用NS_OPTIONS，否则使用NS_ENUM。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;NS-OPTIONS&quot;&gt;&lt;a href=&quot;#NS-OPTIONS&quot; class=&quot;headerlink&quot; title=&quot;NS_OPTIONS&quot;&gt;&lt;/a&gt;NS_OPTIONS&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;typedef NS_OPTIONS(NSUInteger,
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods的安装和使用:一</title>
    <link href="http://oneredfox.github.io/2014/06/11/%E4%BD%BF%E7%94%A8CocoaPods/"/>
    <id>http://oneredfox.github.io/2014/06/11/使用CocoaPods/</id>
    <published>2014-06-10T16:00:00.000Z</published>
    <updated>2017-07-27T02:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里写下CocoaPods</p>
<h3 id="一-CocoaPods-安装"><a href="#一-CocoaPods-安装" class="headerlink" title="一: CocoaPods 安装"></a>一: CocoaPods 安装</h3><p>  CocoaPods的安装方式很简单,Mac下自带ruby,直接使用ruby的gem命令即可.<br>  注意:ruby的软件源eubygems.org因为使用亚马逊的云服务,所以被屏蔽掉了,需要更下下ruby的源,这里使用ruby-china提供的镜像服务(如果直接使用sudo gem install cocoapods会发现半天没反应)</p>
<p>  1.如果gem版本太低了,可以直接升级gem</p>
<pre><code>sudo gem update --system
</code></pre><p>  2.移除rubygems.org</p>
<pre><code>gem sources --remove https://rubygems.org/ 
</code></pre><p>  3.用淘宝提供的镜像服务替换源</p>
<pre><code>gem sources -a https://ruby.taobao.org/
</code></pre><p>  4.安装好后可以用 <code>gem sources -l</code>检查当前SOURCES源<br>   只有在终端出现下面文字才表明是成功的</p>
<pre><code>*** CURRENT SOURCES ***                                             
https://ruby.taobao.org/
</code></pre><p>  5.上面所有的命令完成时,在终端运行</p>
<pre><code>sudo gem install -n /usr/local/bin cocoapods --pre
</code></pre><p>  6.注意点:</p>
<pre><code>ruby -v可以查看当前ruby版本,
rvm list known查看目前的所有ruby版本,
如果提示command not found 请先安装rvm,
curl -L get.rvm.io | bash -s stable
</code></pre><p>  7.使用CocoaPods的镜像索引<br>    所有项目的Podspec文件都托管在<a href="https://github.com/CocoaPods/Specs.第一次执行pod" target="_blank" rel="external">https://github.com/CocoaPods/Specs.第一次执行pod</a> setup时,CocoaPods会将这些Podsapce索引文件更新到本地的~/.cocoapods/路径下,这个所以文件比较大,第一次更新时非常慢.友好人士在国内的服务器建立了Cocoapods索引库的镜像,所以执行索引跟新操作时候会快很多.具体操作方法如下:</p>
<pre><code>pod repo remove master
git clone https://github.com/CocoaPods/Specs.git ~/.cocoapods/repos/master
pod repo update  
</code></pre><p>   这是使用gitcafe上的镜像,将以上代码中的 <a href="https://gitcafe.com/akuandev/Specs.git" target="_blank" rel="external">https://gitcafe.com/akuandev/Specs.git</a> 替换成 <a href="https://git.oschina.net/akuandev/Specs.git" target="_blank" rel="external">https://git.oschina.net/akuandev/Specs.git</a> 即可使用oschina上的镜像。</p>
<h3 id="二-CocoaPods使用"><a href="#二-CocoaPods使用" class="headerlink" title="二:CocoaPods使用"></a>二:CocoaPods使用</h3><p>  1.新建项目,cd到目录下<br>  2.vim一个名为Podfile的文件,如下格式,并将以来的库添加进去</p>
<pre><code>platform :ios,10.2
target &apos;your project&apos; do
pod &apos;AFNetworking&apos;, &apos;~&gt;3.0.4&apos;
end
</code></pre><p>  3.执行命令 <code>pod install</code><br>    现在,第三方已经下载完并且设置好了编译参数和依赖,只需要记住如下两点:<br>    3.1使用CocoaPods生成的 .xcworkspace文件来打开工程<br>    3.2每次更改了Podfile文件,都需要重新执行以下 <code>pod insatall</code> 命令 </p>
<p>  4.如果不知道第三方库的最新版本,可以使用命令行进行查找</p>
<pre><code>pod search AFNetworking
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里写下CocoaPods&lt;/p&gt;
&lt;h3 id=&quot;一-CocoaPods-安装&quot;&gt;&lt;a href=&quot;#一-CocoaPods-安装&quot; class=&quot;headerlink&quot; title=&quot;一: CocoaPods 安装&quot;&gt;&lt;/a&gt;一: CocoaPods 安装&lt;/h3&gt;&lt;p
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>通过Nvm安装Node</title>
    <link href="http://oneredfox.github.io/2014/02/21/%E7%94%A8Nvm%E5%AE%89%E8%A3%85Node/"/>
    <id>http://oneredfox.github.io/2014/02/21/用Nvm安装Node/</id>
    <published>2014-02-21T14:55:08.000Z</published>
    <updated>2017-07-27T02:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-安装HomeBrew"><a href="#一-安装HomeBrew" class="headerlink" title="一: 安装HomeBrew"></a>一: 安装HomeBrew</h2><p>打开终端,输入</p>
<pre><code>//如果已安装HomeBrew 无需执行此行
$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre><h2 id="二-安装Nvm"><a href="#二-安装Nvm" class="headerlink" title="二: 安装Nvm"></a>二: 安装Nvm</h2><p><code>$ brew install nvm</code></p>
<h2 id="三-在shell中使用nvm命令"><a href="#三-在shell中使用nvm命令" class="headerlink" title="三: 在shell中使用nvm命令"></a>三: 在shell中使用nvm命令</h2><p>2.1 首先查看是否有.bash_profile文件,没有cd到文件夹执行以下命令</p>
<pre><code>$ vim .bash_profile
</code></pre><p>然后输入以下命令:</p>
<pre><code>export NVM_DIR=~/.nvm`
source $(brew --prefix nvm)/nvm.sh
</code></pre><p>最后重新source</p>
<p><code>$ source .bash_profile</code></p>
<h2 id="四-用nvm安装Node"><a href="#四-用nvm安装Node" class="headerlink" title="四: 用nvm安装Node    "></a>四: 用nvm安装Node    </h2><p>在终端输入以下命令:</p>
<pre><code>$ nvm ls-remote  查看 所有的node可用版本
$ nvm install xxx  下载你想要的版本
$ nvm use xxx  使用指定版本的node 
$ nvm alias default xxx  每次启动终端都使用该版本的node 
</code></pre><h2 id="五-安装完成"><a href="#五-安装完成" class="headerlink" title="五: 安装完成"></a>五: 安装完成</h2><p>在终端输入以下命令:</p>
<pre><code>$ node -v
$ npm -v 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-安装HomeBrew&quot;&gt;&lt;a href=&quot;#一-安装HomeBrew&quot; class=&quot;headerlink&quot; title=&quot;一: 安装HomeBrew&quot;&gt;&lt;/a&gt;一: 安装HomeBrew&lt;/h2&gt;&lt;p&gt;打开终端,输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//如果已
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>刚刚搭建了个博客</title>
    <link href="http://oneredfox.github.io/2014/02/11/%E5%88%9A%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://oneredfox.github.io/2014/02/11/刚搭建的博客/</id>
    <published>2014-02-10T16:00:00.000Z</published>
    <updated>2017-07-27T02:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚搭建了个博客,样式入下图,主要分三步来搭建:</p>
<p><img src="http://r.photo.store.qq.com/psb?/V11CFKUe0ogDzM/BMMMWCJK.M7b2Z8WVt*o*xVg4AAxvicKCWBkdeiIIEM!/r/dLMAAAAAAAAA" alt="作者的blog截图"> </p>
<h2 id="一-创建Github域名和控件"><a href="#一-创建Github域名和控件" class="headerlink" title="一: 创建Github域名和控件"></a>一: 创建Github域名和控件</h2><h4 id="1-1-注册"><a href="#1-1-注册" class="headerlink" title="1.1 注册"></a>1.1 注册</h4><p>需要准备一个Github账号(不会的可以百度教程),需要注意的是username,这个名字将会是你的域名,比如:username.github.io.</p>
<h4 id="1-2-创建仓库"><a href="#1-2-创建仓库" class="headerlink" title="1.2 创建仓库"></a>1.2 创建仓库</h4><p>然后创建仓库(repository)来存储我们的网站,点击首页任意位置出现的 New repository 按钮创建仓库,Respository name中的username.github.io的username一定与前面的一致,username在下面会用到. </p>
<h2 id="二-安装"><a href="#二-安装" class="headerlink" title="二: 安装"></a>二: 安装</h2><p>我们安装的是Hexo,基于Nodejs,是比较流行的博客框架,我们需要安装的工具都包括Hexo,Git,Nodejs.</p>
<h4 id="2-1-安装HomeBrew"><a href="#2-1-安装HomeBrew" class="headerlink" title="2.1 安装HomeBrew"></a>2.1 安装HomeBrew</h4><p><a href="https://oneredfox.github.io/2014/02/21/%E7%94%A8Nvm%E5%AE%89%E8%A3%85Node/">可以参考作者的另一篇文章</a></p>
<h4 id="2-2-安装Git"><a href="#2-2-安装Git" class="headerlink" title="2.2 安装Git"></a>2.2 安装Git</h4><p><a href="https://oneredfox.github.io/2015/06/11/%E4%BD%BF%E7%94%A8CocoaPods/">可以参考作者的另一篇文章</a></p>
<h4 id="2-3-安装Nodejs"><a href="#2-3-安装Nodejs" class="headerlink" title="2.3 安装Nodejs"></a>2.3 安装Nodejs</h4><p>已经安装了nvm,这是Nodejs版本管理器,可以轻松切换Nodejs版本.<br><a href="https://oneredfox.github.io/2014/02/21/%E7%94%A8Nvm%E5%AE%89%E8%A3%85Node/">作者的这篇文章有怎么安装Node</a></p>
<h4 id="2-4-安装Hexo"><a href="#2-4-安装Hexo" class="headerlink" title="2.4 安装Hexo"></a>2.4 安装Hexo</h4><p>输入以下命令</p>
<pre><code>$ sudo npm install hexo-cli -g
</code></pre><p>所有工具安装完成后,就可以开始搭建博客了</p>
<h2 id="三-搭建"><a href="#三-搭建" class="headerlink" title="三: 搭建"></a>三: 搭建</h2><p>接下来我们用Hexo初始化一个博客,然后加上自己喜欢的主题,写上第一篇文章,然后发布到自己的个人Github网站(username.github.io).</p>
<h4 id="3-1-搭建博客"><a href="#3-1-搭建博客" class="headerlink" title="3.1 搭建博客"></a>3.1 搭建博客</h4><p>将下面的username替换成你自己的username(其实也无所谓),执行成功后,会创建出一个名为username.github.io的文件夹</p>
<pre><code>$ hexo init username.github.io
</code></pre><h4 id="3-2-安装主题"><a href="#3-2-安装主题" class="headerlink" title="3.2 安装主题"></a>3.2 安装主题</h4><p>作者用的是<a href="https://github.com/monniya/hexo-theme-new-vno" target="_blank" rel="external">喵神的主题</a>,<a href="https://hexo.io/themes/" target="_blank" rel="external">点击查看更多主题</a></p>
<p>在终端输入以下命令:</p>
<pre><code>$ cd username.github.io
//克隆主题
$ git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><p>修改基础配置:<br>打开文件位置username.github.io/_config.yml修改几个键值对,下面把几个必须设置的列出来按需求修改,记得保存,还有注意配置的键值之间一定要有空格.<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">更多设置</a></p>
<blockquote>
<p>title: 刘子兴的博客 //博客名字<br>description: 正在潜心修行中 //描述<br>author: 刘子兴  //作者名字<br>language: zh-Hans  //语言<br>url: <a href="http://oneredfox.github.io">http://oneredfox.github.io</a>  //git链接<br>type: git  //发布类型<br>theme: next<br>repo: <a href="https://github.com/oneredfox/oneredfox.github.io.git" target="_blank" rel="external">https://github.com/oneredfox/oneredfox.github.io.git</a> //git链接            </p>
</blockquote>
<h2 id="四-写文章-发布"><a href="#四-写文章-发布" class="headerlink" title="四: 写文章,发布"></a>四: 写文章,发布</h2><h4 id="4-1写文章"><a href="#4-1写文章" class="headerlink" title="4.1写文章"></a>4.1写文章</h4><p>在username.github.io/source/_posts文件夹下创建一个.md文件,(用Macdown语言写)<br>写入以下代码:</p>
<pre><code>---
title: 刚刚搭建了个博客
date: 2013-02-11
tags: 三尾
---
今天天气很好
</code></pre><h4 id="4-1测试"><a href="#4-1测试" class="headerlink" title="4.1测试"></a>4.1测试</h4><pre><code>$ hexo s
</code></pre><p>你可以在浏览器中输入<a href="https://localhost:4000" target="_blank" rel="external">https://localhost:4000</a> 访问了,访问成功就说明OK了</p>
<h4 id="4-2hexo-deployer-git自动部署发布工具"><a href="#4-2hexo-deployer-git自动部署发布工具" class="headerlink" title="4.2hexo-deployer-git自动部署发布工具"></a>4.2hexo-deployer-git自动部署发布工具</h4><pre><code>$ npm install hexo-deployer-git --save
</code></pre><h4 id="4-3发布"><a href="#4-3发布" class="headerlink" title="4.3发布"></a>4.3发布</h4><pre><code>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d
</code></pre><p>在终端cd到username.github.io文件下,</p>
<p>作者更新安装的node版本:7.0</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚刚搭建了个博客,样式入下图,主要分三步来搭建:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://r.photo.store.qq.com/psb?/V11CFKUe0ogDzM/BMMMWCJK.M7b2Z8WVt*o*xVg4AAxvicKCWBkdeiIIEM!/r/
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
</feed>
