<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘子兴的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://oneredfox.github.io/"/>
  <updated>2017-07-26T08:04:42.000Z</updated>
  <id>http://oneredfox.github.io/</id>
  
  <author>
    <name>刘子兴</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NSCache</title>
    <link href="http://oneredfox.github.io/2016/04/21/NSCache/"/>
    <id>http://oneredfox.github.io/2016/04/21/NSCache/</id>
    <published>2016-04-21T14:55:08.000Z</published>
    <updated>2017-07-26T08:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NSCache-基本介绍"><a href="#NSCache-基本介绍" class="headerlink" title="NSCache 基本介绍"></a>NSCache 基本介绍</h1><p><code>NSCache</code>是苹果官方提供的缓存类,它的用法和<code>NSMutableDictionary</code>非常类似.</p>
<p><code>NSCache</code>是一个类似于集合的容器,即缓存.它存储key-value,这一点非常类似<code>NSDictionary</code>. 开发者一般用<code>NSCache</code>来缓存临时存储短时间但是使用创建成本高的对象,重用这些对象可以优化性能,因为他们的值不需要被重新计算.另外一方面,这些对象对于程序来说是不要紧的,在内存紧张的时候会被丢弃,如果对象被丢弃了,则下次使用的时候需要重新计算.</p>
<p>当一个key-value对在缓存时,缓存维护它的一个强引用.存储在<code>NSCache</code>中的通用数据类型通常是实现了<code>NSDiscardableContent</code>协议的对象.在缓存中存储这类对象的好处是,当你不需要它的时候可以丢弃这些内容,以节省内存.默认情况下,缓存中的<code>NSDiscardableContent</code>对象在其内容被丢弃的时候,会被移除缓存,如果一个<code>NSDiscardableContent</code>被放进缓存，则在对象被移除时，缓存会调用<code>discardContentIfPossible</code>方法。</p>
<p><code>NSCache</code>与可变集合的不同:   </p>
<ol>
<li><code>NSCache</code>类结合了各种自动删除策略，以确保不会占用过多的系统内存。如果其它应用需要内存时，系统自动执行这些策略。当调用这些策略时，会从缓存中删除一些对象，以最大限度减少内存的占用</li>
<li><code>NSCache</code>是线程安全的，我们可以在不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域</li>
<li>不像<code>NSMutableDictionary</code>对象，一个缓存对象不会拷贝key对象</li>
</ol>
<h2 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h2><p>@property NSUInteger countLimit 缓存应持有的对象的最大数量。</p>
<pre><code>This is not a strict limit—if the cache goes over the limit, an object in the cache could be evicted instantly, later, or possibly never, depending on the implementation details of the cache. 
这不是一个严格的限制。如果缓存的数量超过这个数量，缓存中的一个对象可能会被立即丢弃、或者稍后、也可能永远不会，具体依赖于缓存的实现细节。
</code></pre><p>@property NSUInteger totalCostLimit  </p>
<pre><code>limits are imprecise/not strict
来限定缓存能维持的最大内存,但totalCostLimit也不是一个严格限制
</code></pre><p>@property BOOL evictsObjectsWithDiscardedContent;</p>
<pre><code>是否自动清理缓存,默认是YES
</code></pre><h2 id="存取方法介绍"><a href="#存取方法介绍" class="headerlink" title="存取方法介绍"></a>存取方法介绍</h2><pre><code>- setObject:forKey:
- setObject:forKey:cost:
- removeObjectForKey:
- removeAllObjects
</code></pre><h2 id="NSCacheDelegate"><a href="#NSCacheDelegate" class="headerlink" title="NSCacheDelegate"></a>NSCacheDelegate</h2><pre><code>- (void)cache:(NSCache *)cachewillEvictObject:(id)obj
</code></pre><p> 缓存将要删除对象时调用，不能在此方法中修改缓存</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NSCache-基本介绍&quot;&gt;&lt;a href=&quot;#NSCache-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;NSCache 基本介绍&quot;&gt;&lt;/a&gt;NSCache 基本介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;NSCache&lt;/code&gt;是苹果官方提供的缓存
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>NS_OPTIONS与NS_ENUM的区别</title>
    <link href="http://oneredfox.github.io/2015/07/20/NS_OPTIONS%E4%B8%8ENS_ENUM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://oneredfox.github.io/2015/07/20/NS_OPTIONS与NS_ENUM的区别/</id>
    <published>2015-07-20T14:55:08.000Z</published>
    <updated>2017-07-19T07:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="NS-OPTIONS"><a href="#NS-OPTIONS" class="headerlink" title="NS_OPTIONS"></a>NS_OPTIONS</h3><pre><code>typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) { 
    SDWebImageRetryFailed = 1 &lt;&lt; 0, //值为2的0次方
    SDWebImageLowPriority = 1 &lt;&lt; 1, //值为2的1次方 
    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, //值为2的2次方 
    SDWebImageProgressiveDownload = 1 &lt;&lt; 3, //值为2的3次方     
    SDWebImageRefreshCached = 1 &lt;&lt; 4 //值为2的4次方 
};
</code></pre><blockquote>
<p>小括号中第一个为NSUInteger这个为固定值，第二个为枚举名字(自己定义),大括号中枚举项必须全部包含小括号的枚举类型，枚举项后面再跟上几个值的区别，这里枚举项是NSUInteger类型</p>
</blockquote>
<h3 id="NS-ENUM"><a href="#NS-ENUM" class="headerlink" title="NS_ENUM"></a>NS_ENUM</h3><pre><code>typedef NS_ENUM(NSInteger, SDWebImageOptions {
     SDWebImageRetryFailed = 0, //值为0            SDWebImageLowPriority = 1, //值为1        SDWebImageCacheMemoryOnly = 2 //值为2       
};
</code></pre><blockquote>
<p>小括号中第一个为NSInteger这个为固定值，第二个为枚举名称(自己定义)，大括号中枚举项必须包含小括号中自己定义的枚举类型，枚举项自己加后缀以视区别，大括号中的枚举项的值可自定义，若是定义了枚举项其中一项的值后面依次在它的前一项的值上加1，如这样：</p>
</blockquote>
<pre><code>typedef NS_ENUM(NSInteger, SDWebImageOptions) {
    SDWebImageRetryFailed = 0, //值为0            SDWebImageLowPriority, //值为1             SDWebImageCacheMemoryOnly //值为2      
 }; 
</code></pre><p>//或者这样 </p>
<pre><code>typedef NS_ENUM(NSInteger,SDWebImageOptions) {
    SDWebImageRetryFailed = 0, //值为0            SDWebImageLowPriority = 2, //值为2         SDWebImageCacheMemoryOnly //值为3    
};
</code></pre><p>//若是都不定义值，默认第一项为0，后面依次枚举项的值加1。</p>
<p>当然也可以下方这样写枚举，但是官方不推荐:</p>
<pre><code>typedef enum { 
    SDWebImageRetryFailed = 0,                 SDWebImageLowPriority = 1,
     SDWebImageCacheMemoryOnly = 2  
} SDWebImageOptions;
</code></pre><h3 id="NS-ENUM与NS-OPTIONS的区别"><a href="#NS-ENUM与NS-OPTIONS的区别" class="headerlink" title="NS_ENUM与NS_OPTIONS的区别"></a>NS_ENUM与NS_OPTIONS的区别</h3><ul>
<li><p>NS_ENUM枚举项的值为NSInteger，NS_OPTIONS枚举项的值为NSUInteger;</p>
<blockquote>
<p>这里为什么NS_ENUM用NSInteger，NS_OPTIONS用NSUInteger看后  面总结</p>
</blockquote>
</li>
<li><p>NS_ENUM定义通用枚举，NS_OPTIONS定义位移枚举</p>
<blockquote>
<p>位移枚举即是在你需要的地方可以同时存在多个枚举值如这样：</p>
</blockquote>
<pre><code>UISwipeGestureRecognizer *swipeGR = [[UISwipeGestureRecognizer alloc] init];
swipeGR.direction = UISwipeGestureRecognizerDirectionDown | UISwipeGestureRecognizerDirectionLeft | UISwipeGestureRecognizerDirectionRight;
</code></pre><blockquote>
<p>而NS_ENUM定义的枚举不能几个枚举项同时存在，只能选择其中一项，像这样：</p>
</blockquote>
<pre><code>   UITextField *textfiled =[[UITextField alloc]init];
textfiled.keyboardType = UIKeyboardTypeDefault;
</code></pre></li>
<li><p>NS_OPTIONS的枚举项的值需要像这样表示1 &lt;&lt; 0，1 &lt;&lt; 1，2的几次方这样，而NS_ENUM可以直接给像1，2，3这样。</p>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>  这里为什么会出现NS_OPTIONS与NS_ENUM且为什么不直接一个就行，且枚举值可多选。因为有个是否将代码按照C++模式编译，若是不按照C++模式编译，NS_OPTIONS与NS_ENUM展开方式就一样，若是要按照C++模式编译，就不同了。在使用或运算操作两个枚举值时，C++默认为运算结果的数据类型是枚举的底层数据类型即NSUInteger,且C++不允许它隐式转换为枚举类型本身，所以C++模式下定义了NS_OPTIONS宏以保证不出现类型转换。<br>到了这我们就知道了只要枚举值需要用到按位或（2个及以上枚举值可多个存在）就使用NS_OPTIONS，否则使用NS_ENUM。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;NS-OPTIONS&quot;&gt;&lt;a href=&quot;#NS-OPTIONS&quot; class=&quot;headerlink&quot; title=&quot;NS_OPTIONS&quot;&gt;&lt;/a&gt;NS_OPTIONS&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;typedef NS_OPTIONS(NSUInteger,
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods的安装和使用:一</title>
    <link href="http://oneredfox.github.io/2015/06/11/%E4%BD%BF%E7%94%A8CocoaPods/"/>
    <id>http://oneredfox.github.io/2015/06/11/使用CocoaPods/</id>
    <published>2015-06-10T16:00:00.000Z</published>
    <updated>2017-07-26T08:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里写下CocoaPods</p>
<h3 id="一-CocoaPods-安装"><a href="#一-CocoaPods-安装" class="headerlink" title="一: CocoaPods 安装"></a>一: CocoaPods 安装</h3><p>  CocoaPods的安装方式很简单,Mac下自带ruby,直接使用ruby的gem命令即可.<br>  注意:ruby的软件源eubygems.org因为使用亚马逊的云服务,所以被屏蔽掉了,需要更下下ruby的源,这里使用ruby-china提供的镜像服务(如果直接使用sudo gem install cocoapods会发现半天没反应)</p>
<p>  1.如果gem版本太低了,可以直接升级gem</p>
<pre><code>sudo gem update --system
</code></pre><p>  2.移除rubygems.org</p>
<pre><code>gem sources --remove https://rubygems.org/ 
</code></pre><p>  3.用淘宝提供的镜像服务替换源</p>
<pre><code>gem sources -a https://ruby.taobao.org/
</code></pre><p>  4.安装好后可以用 <code>gem sources -l</code>检查当前SOURCES源<br>   只有在终端出现下面文字才表明是成功的</p>
<pre><code>*** CURRENT SOURCES ***                                             
https://ruby.taobao.org/
</code></pre><p>  5.上面所有的命令完成时,在终端运行</p>
<pre><code>sudo gem install -n /usr/local/bin cocoapods --pre
</code></pre><p>  6.注意点:</p>
<pre><code>ruby -v可以查看当前ruby版本,
rvm list known查看目前的所有ruby版本,
如果提示command not found 请先安装rvm,
curl -L get.rvm.io | bash -s stable
</code></pre><p>  7.使用CocoaPods的镜像索引<br>    所有项目的Podspec文件都托管在<a href="https://github.com/CocoaPods/Specs.第一次执行pod" target="_blank" rel="external">https://github.com/CocoaPods/Specs.第一次执行pod</a> setup时,CocoaPods会将这些Podsapce索引文件更新到本地的~/.cocoapods/路径下,这个所以文件比较大,第一次更新时非常慢.友好人士在国内的服务器建立了Cocoapods索引库的镜像,所以执行索引跟新操作时候会快很多.具体操作方法如下:</p>
<pre><code>pod repo remove master
git clone https://github.com/CocoaPods/Specs.git ~/.cocoapods/repos/master
pod repo update  
</code></pre><p>   这是使用gitcafe上的镜像,将以上代码中的 <a href="https://gitcafe.com/akuandev/Specs.git" target="_blank" rel="external">https://gitcafe.com/akuandev/Specs.git</a> 替换成 <a href="https://git.oschina.net/akuandev/Specs.git" target="_blank" rel="external">https://git.oschina.net/akuandev/Specs.git</a> 即可使用oschina上的镜像。</p>
<h3 id="二-CocoaPods使用"><a href="#二-CocoaPods使用" class="headerlink" title="二:CocoaPods使用"></a>二:CocoaPods使用</h3><p>  1.新建项目,cd到目录下<br>  2.vim一个名为Podfile的文件,如下格式,并将以来的库添加进去</p>
<pre><code>platform :ios,10.2
target &apos;your project&apos; do
pod &apos;AFNetworking&apos;, &apos;~&gt;3.0.4&apos;
end
</code></pre><p>  3.执行命令 <code>pod install</code><br>    现在,第三方已经下载完并且设置好了编译参数和依赖,只需要记住如下两点:<br>    3.1使用CocoaPods生成的 .xcworkspace文件来打开工程<br>    3.2每次更改了Podfile文件,都需要重新执行以下 <code>pod insatall</code> 命令 </p>
<p>  4.如果不知道第三方库的最新版本,可以使用命令行进行查找</p>
<pre><code>pod search AFNetworking
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里写下CocoaPods&lt;/p&gt;
&lt;h3 id=&quot;一-CocoaPods-安装&quot;&gt;&lt;a href=&quot;#一-CocoaPods-安装&quot; class=&quot;headerlink&quot; title=&quot;一: CocoaPods 安装&quot;&gt;&lt;/a&gt;一: CocoaPods 安装&lt;/h3&gt;&lt;p
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>日常总结</title>
    <link href="http://oneredfox.github.io/2015/04/20/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    <id>http://oneredfox.github.io/2015/04/20/日常总结/</id>
    <published>2015-04-20T14:55:08.000Z</published>
    <updated>2017-07-20T03:19:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-我们有时候需要将一个Core-Foundation对象转换成一个Objective-C对象-这个时候我们需要告诉编译器-转换过程中引用计数如何调整-这时候就引入了与bridge相关的关键字"><a href="#一-我们有时候需要将一个Core-Foundation对象转换成一个Objective-C对象-这个时候我们需要告诉编译器-转换过程中引用计数如何调整-这时候就引入了与bridge相关的关键字" class="headerlink" title="一:我们有时候需要将一个Core Foundation对象转换成一个Objective-C对象,这个时候我们需要告诉编译器,转换过程中引用计数如何调整,这时候就引入了与bridge相关的关键字,"></a>一:我们有时候需要将一个Core Foundation对象转换成一个Objective-C对象,这个时候我们需要告诉编译器,转换过程中引用计数如何调整,这时候就引入了与bridge相关的关键字,</h3><ol>
<li>__bridge:只做类型转换,不修改相关对象的引用技术,原来的Core Foundation对象在不用时,需要调用CFRelease方法;</li>
<li>__bridge_retailned:类型转换后,将先关对象的引用技术加1,原来的Core Foundation对象不用时,需要调用CFRelease方法;</li>
<li>__bridge_transfer:类型转换后,将该对象的引用计数交给arc管理,原来的Core Foundation对象在不用时,不需要调用CFRelease方法.</li>
</ol>
<h3 id="二-UIWindow有个属性WindowLevel-该属性蒂尼了UIWindow的层级-系统定义的WindowLevel一共有3种取值-如下所示"><a href="#二-UIWindow有个属性WindowLevel-该属性蒂尼了UIWindow的层级-系统定义的WindowLevel一共有3种取值-如下所示" class="headerlink" title="二:UIWindow有个属性WindowLevel,该属性蒂尼了UIWindow的层级,系统定义的WindowLevel一共有3种取值,如下所示:"></a>二:UIWindow有个属性WindowLevel,该属性蒂尼了UIWindow的层级,系统定义的WindowLevel一共有3种取值,如下所示:</h3><pre><code>UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal;
UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert;
UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar;
</code></pre><p>   程序默认热UIWindow的层级是UIWindowLevelNormal,当系统需要在上面覆盖UIAlertContronler时,就会创建一个层级是UIWindowLevelAlert的UIWindow,因为其WindowLevel值更高,所以覆盖在上面了.<br>   需要注意的是:在实际应用中,WindowLevel并不仅限于上面三个值.</p>
<h3 id="三-UITableView的plain样式下，取消区头停滞效果"><a href="#三-UITableView的plain样式下，取消区头停滞效果" class="headerlink" title="三:UITableView的plain样式下，取消区头停滞效果"></a>三:UITableView的plain样式下，取消区头停滞效果</h3><pre><code> - (void)scrollViewDidScroll:(UIScrollView*)scrollView
{
    CGFloat sectionHeaderHeight = sectionHead.height;
    if (scrollView.contentOffset.y=0) {
         scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);
    } else if (scrollView.contentOffset.y&gt;=sectionHeaderHeight) {
      scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);
    }
}
</code></pre><p>其实就是group样式</p>
<h3 id="四-获取汉语的拼音"><a href="#四-获取汉语的拼音" class="headerlink" title="四:获取汉语的拼音"></a>四:获取汉语的拼音</h3><pre><code>+ (NSString *)transform:(NSString *)chinese
{    
   //将NSString装换成NSMutableString 
   NSMutableString *pinyin = [chinese mutableCopy];    
   //将汉字转换为拼音(带音标)    
   CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);    
   NSLog(@&quot;%@&quot;, pinyin);    
   //去掉拼音的音标    
  CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);    
   NSLog(@&quot;%@&quot;, pinyin);    
   //返回最近结果    
   return pinyin;
 }  
</code></pre><h3 id="五-NSArray-快速求总和-最大值-最小值-和-平均值"><a href="#五-NSArray-快速求总和-最大值-最小值-和-平均值" class="headerlink" title="五:NSArray 快速求总和 最大值 最小值 和 平均值"></a>五:NSArray 快速求总和 最大值 最小值 和 平均值</h3><pre><code>NSArray *array = [NSArray arrayWithObjects:@&quot;2.0&quot;, @&quot;2.3&quot;, @&quot;3.0&quot;, @&quot;4.0&quot;, @&quot;10&quot;, nil];
//和
CGFloat sum = [[array valueForKeyPath:@&quot;@sum.floatValue&quot;] floatValue];
//平均值
CGFloat avg = [[array valueForKeyPath:@&quot;@avg.floatValue&quot;] floatValue];
//最大值
CGFloat max =[[array valueForKeyPath:@&quot;@max.floatValue&quot;] floatValue];
//最小值
CGFloat min =[[array valueForKeyPath:@&quot;@min.floatValue&quot;] floatValue];
NSLog(@&quot;%f\n%f\n%f\n%f&quot;,sum,avg,max,min);
</code></pre><h3 id="六-修改UITextField中Placeholder的文字颜色"><a href="#六-修改UITextField中Placeholder的文字颜色" class="headerlink" title="六:修改UITextField中Placeholder的文字颜色"></a>六:修改UITextField中Placeholder的文字颜色</h3><pre><code> //方法一:
[textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];
[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@&quot;_placeholderLabel.font&quot;];

方法二:
NSString *string = @&quot;美丽新世界&quot;;
NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:string];

[attributedString addAttribute:NSForegroundColorAttributeName
                         value:[UIColor redColor]
                         range:NSMakeRange(0, [string length])];

[attributedString addAttribute:NSFontAttributeName
                         value:[UIFont systemFontOfSize:16]
                         range:NSMakeRange(0, [string length])];

self.textField.attributedPlaceholder = attributedString;
</code></pre><h3 id="七-取消UICollectionView的隐式动画"><a href="#七-取消UICollectionView的隐式动画" class="headerlink" title="七:取消UICollectionView的隐式动画"></a>七:取消UICollectionView的隐式动画</h3><p>   UICollectionView在reloadItems的时候，默认会附加一个隐式的fade动画，有时候很讨厌，尤其是当你的cell是复合cell的情况下(比如cell使用到了UIStackView)。</p>
<pre><code>//方法一
[UIView performWithoutAnimation:^{
   [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
}];

//方法二
[UIView animateWithDuration:0 animations:^{
   [collectionView performBatchUpdates:^{
   [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
} completion:nil];
}];

//方法三
[UIView setAnimationsEnabled:NO];
[self.trackPanel performBatchUpdates:^{
   [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
} completion:^(BOOL finished) {
   [UIView setAnimationsEnabled:YES];
}];
</code></pre><h3 id="八-图片上绘制文字"><a href="#八-图片上绘制文字" class="headerlink" title="八:图片上绘制文字"></a>八:图片上绘制文字</h3><pre><code>- (UIImage *)imageWithTitle:(NSString *)title fontSize:(CGFloat)fontSize
{
//画布大小
CGSize size=CGSizeMake(self.size.width,self.size.height);
//创建一个基于位图的上下文
UIGraphicsBeginImageContextWithOptions(size,NO,0.0);//opaque:NO  scale:0.0

[self drawAtPoint:CGPointMake(0.0,0.0)];

//文字居中显示在画布上
NSMutableParagraphStyle* paragraphStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy];
paragraphStyle.lineBreakMode = NSLineBreakByCharWrapping;
paragraphStyle.alignment=NSTextAlignmentCenter;//文字居中

//计算文字所占的size,文字居中显示在画布上
CGSize sizeText=[title boundingRectWithSize:self.size options:NSStringDrawingUsesLineFragmentOrigin
                                 attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:fontSize]}context:nil].size;
CGFloat width = self.size.width;
CGFloat height = self.size.height;

CGRect rect = CGRectMake((width-sizeText.width)/2, (height-sizeText.height)/2, sizeText.width, sizeText.height);
//绘制文字
[title drawInRect:rect withAttributes:@{ NSFontAttributeName:[UIFont systemFontOfSize:fontSize],NSForegroundColorAttributeName:[ UIColor whiteColor],NSParagraphStyleAttributeName:paragraphStyle}];

//返回绘制的新图形
UIImage *newImage= UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
return newImage;
}
</code></pre><h3 id="九-UIView设置部分圆角"><a href="#九-UIView设置部分圆角" class="headerlink" title="九:UIView设置部分圆角"></a>九:UIView设置部分圆角</h3><pre><code>- (void)setCornerWithTopLeft:(BOOL)topLeft topRight:(BOOL)topRight bottomLeft:(BOOL)bottomLeft bottomRight:(BOOL)bottomRight andSize:(CGSize)size {

   CGRect rect = self.bounds;
   UIRectCorner corner;
   if (topLeft) {
       corner = corner | UIRectCornerTopLeft;
   };
   if (topRight) {
       corner = corner | UIRectCornerTopRight;
   };
   if (bottomLeft) {
       corner = corner | UIRectCornerBottomLeft;
   };
   if (bottomRight) {
       corner = corner | UIRectCornerBottomRight;
   };

   UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corner cornerRadii:size];
   CAShapeLayer *masklayer = [[CAShapeLayer alloc]init];//创建shapelayer
   masklayer.frame = self.bounds;
   masklayer.path = path.CGPath;//设置路径
  self.layer.mask = masklayer;
}
</code></pre><h3 id="十-给UIView设置图片"><a href="#十-给UIView设置图片" class="headerlink" title="十:给UIView设置图片"></a>十:给UIView设置图片</h3><pre><code>UIImage *image = [UIImage imageNamed:@&quot;image&quot;];
View.layer.contents = (__bridge id _Nullable)(image.CGImage);
View.layer.contentsRect = CGRectMake(0, 0, 0.5, 0.5);
</code></pre><h3 id="十一-防止scrollView手势覆盖侧滑手势"><a href="#十一-防止scrollView手势覆盖侧滑手势" class="headerlink" title="十一:防止scrollView手势覆盖侧滑手势"></a>十一:防止scrollView手势覆盖侧滑手势</h3><pre><code>[scrollView.panGestureRecognizerrequireGestureRecognizerToFail:self.navigationController.interactivePopGestureRecognizer];
</code></pre><h3 id="十一-检查字符串中是否含有中文-NSString-Extension"><a href="#十一-检查字符串中是否含有中文-NSString-Extension" class="headerlink" title="十一:检查字符串中是否含有中文(NSString+Extension)"></a>十一:检查字符串中是否含有中文(NSString+Extension)</h3><pre><code>- (BOOL)checkIsChinese {
   for(int i=0; i&lt; [self length]; i++){
       int a = [self characterAtIndex:i];
       if( a &gt; 0x4e00 &amp;&amp; a &lt; 0x9fff) {
          return YES;
       } 
    }
   return NO;
}
</code></pre><h3 id="十二-UITextField每四位加一个空格-实现代理"><a href="#十二-UITextField每四位加一个空格-实现代理" class="headerlink" title="十二:UITextField每四位加一个空格,实现代理"></a>十二:UITextField每四位加一个空格,实现代理</h3><pre><code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string {
   // 四位加一个空格
   if ([string isEqualToString:@&quot;&quot;]) {
       // 删除字符
       if ((textField.text.length - 2) % 5 == 0) {
           textField.text = [textField.text substringToIndex:textField.text.length - 1];
       }
       return YES;
   } else {
       if (textField.text.length % 5 == 0) {
           textField.text = [NSString stringWithFormat:@&quot;%@ &quot;, textField.text];
       }
   }
   return YES;
}
</code></pre><h3 id="十三-屏蔽触发事件，2秒后取消屏蔽"><a href="#十三-屏蔽触发事件，2秒后取消屏蔽" class="headerlink" title="十三:屏蔽触发事件，2秒后取消屏蔽"></a>十三:屏蔽触发事件，2秒后取消屏蔽</h3><pre><code>[[UIApplication sharedApplication] beginIgnoringInteractionEvents];
   dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
   [[UIApplication sharedApplication] endIgnoringInteractionEvents]
</code></pre><p>   });</p>
<h3 id="十四-两点之间的距离"><a href="#十四-两点之间的距离" class="headerlink" title="十四:两点之间的距离"></a>十四:两点之间的距离</h3><pre><code>static __inline__ CGFloat CGPointDistanceBetweenTwoPoints(CGPoint point1, CGPoint point2) { CGFloat dx = point2.x - point1.x; CGFloat dy = point2.y - point1.y; return sqrt(dx*dx + dy*dy);}
</code></pre><h3 id="十五-使用UIScrollViewKeyboardDismissMode实现了Message-app的行为"><a href="#十五-使用UIScrollViewKeyboardDismissMode实现了Message-app的行为" class="headerlink" title="十五:使用UIScrollViewKeyboardDismissMode实现了Message app的行为"></a>十五:使用UIScrollViewKeyboardDismissMode实现了Message app的行为</h3><pre><code>UIScrollView有一个很好用的属性keyboardDismissMode,把它设置成UIScrollViewKeyboardDismissModeOnDrag,可以控制键盘在scrollview滚动的时候消失
</code></pre><p>这个属性使用了新的UIScrollViewKeyboardDismissMode enum枚举类型。这个enum枚举类型可能的值如下：</p>
<pre><code>typedef NS_ENUM(NSInteger, UIScrollViewKeyboardDismissMode) {
UIScrollViewKeyboardDismissModeNone,
UIScrollViewKeyboardDismissModeOnDrag,      // dismisses the keyboard when a drag begins
UIScrollViewKeyboardDismissModeInteractive, // the keyboard follows the dragging touch off screen, and may be pulled upward again to cancel the dismiss
} NS_ENUM_AVAILABLE_IOS(7_0);
</code></pre><h3 id="十六-获得当前硬盘空间"><a href="#十六-获得当前硬盘空间" class="headerlink" title="十六:获得当前硬盘空间"></a>十六:获得当前硬盘空间</h3><pre><code>NSFileManager *fm = [NSFileManager defaultManager];
NSDictionary *fattributes = [fm attributesOfFileSystemForPath:NSHomeDirectory() error:nil];

NSLog(@&quot;容量%lldG&quot;,[[fattributes objectForKey:NSFileSystemSize] longLongValue]/1000000000);
NSLog(@&quot;可用%lldG&quot;,[[fattributes objectForKey:NSFileSystemFreeSize] longLongValue]/1000000000);
</code></pre><h3 id="十七-给UIView-设置透明度，不影响其他sub-views"><a href="#十七-给UIView-设置透明度，不影响其他sub-views" class="headerlink" title="十七:给UIView 设置透明度，不影响其他sub views"></a>十七:给UIView 设置透明度，不影响其他sub views</h3><p>UIView设置了alpha值，但其中的内容也跟着变透明,如果想不影响其他内容的aopha,可以设置color的alpha.<br>eg:    </p>
<pre><code>[view.backgroundColor colorWithAlphaComponent:0.5];
</code></pre><h3 id="十八-ActivityViewController-使用AirDrop分享"><a href="#十八-ActivityViewController-使用AirDrop分享" class="headerlink" title="十八:ActivityViewController 使用AirDrop分享"></a>十八:ActivityViewController 使用AirDrop分享</h3><pre><code>NSArray *array = @[@&quot;test1&quot;, @&quot;test2&quot;];

UIActivityViewController *activityVC = [[UIActivityViewController alloc] initWithActivityItems:array applicationActivities:nil];

[self presentViewController:activityVC animated:YES
             completion:^{
                 NSLog(@&quot;Air&quot;);
}];
</code></pre><h3 id="十九-APP-屏蔽-触发事件"><a href="#十九-APP-屏蔽-触发事件" class="headerlink" title="十九:APP 屏蔽 触发事件"></a>十九:APP 屏蔽 触发事件</h3><pre><code>[[UIApplication sharedApplication] beginIgnoringInteractionEvents];
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-我们有时候需要将一个Core-Foundation对象转换成一个Objective-C对象-这个时候我们需要告诉编译器-转换过程中引用计数如何调整-这时候就引入了与bridge相关的关键字&quot;&gt;&lt;a href=&quot;#一-我们有时候需要将一个Core-Foundat
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>安装Nvm</title>
    <link href="http://oneredfox.github.io/2014/02/21/%E7%94%A8Nvm%E5%AE%89%E8%A3%85Node/"/>
    <id>http://oneredfox.github.io/2014/02/21/用Nvm安装Node/</id>
    <published>2014-02-21T14:55:08.000Z</published>
    <updated>2017-07-26T08:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-安装HomeBrew"><a href="#一-安装HomeBrew" class="headerlink" title="一: 安装HomeBrew"></a>一: 安装HomeBrew</h2><p>打开终端,输入</p>
<pre><code>//如果已安装HomeBrew 无需执行此行
$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre><h2 id="二-安装Nvm"><a href="#二-安装Nvm" class="headerlink" title="二: 安装Nvm"></a>二: 安装Nvm</h2><p><code>$ brew install nvm</code></p>
<h2 id="三-在shell中使用nvm命令"><a href="#三-在shell中使用nvm命令" class="headerlink" title="三: 在shell中使用nvm命令"></a>三: 在shell中使用nvm命令</h2><p>2.1 首先查看是否有.bash_profile文件,没有cd到文件夹执行以下命令</p>
<pre><code>$ vim .bash_profile
</code></pre><p>然后输入以下命令:</p>
<pre><code>export NVM_DIR=~/.nvm`
source $(brew --prefix nvm)/nvm.sh
</code></pre><p>最后重新source</p>
<p><code>$ source .bash_profile</code></p>
<h2 id="四-用nvm安装Node"><a href="#四-用nvm安装Node" class="headerlink" title="四: 用nvm安装Node    "></a>四: 用nvm安装Node    </h2><p>在终端输入以下命令:</p>
<pre><code>$ nvm ls-remote  查看 所有的node可用版本
$ nvm install xxx  下载你想要的版本
$ nvm use xxx  使用指定版本的node 
$ nvm alias default xxx  每次启动终端都使用该版本的node 
</code></pre><h2 id="五-安装完成"><a href="#五-安装完成" class="headerlink" title="五: 安装完成"></a>五: 安装完成</h2><p>在终端输入以下命令:</p>
<pre><code>$ node -v
$ npm -v 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-安装HomeBrew&quot;&gt;&lt;a href=&quot;#一-安装HomeBrew&quot; class=&quot;headerlink&quot; title=&quot;一: 安装HomeBrew&quot;&gt;&lt;/a&gt;一: 安装HomeBrew&lt;/h2&gt;&lt;p&gt;打开终端,输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//如果已
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>刚刚搭建了个博客</title>
    <link href="http://oneredfox.github.io/2013/02/11/%E5%88%9A%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://oneredfox.github.io/2013/02/11/刚搭建的博客/</id>
    <published>2013-02-10T16:00:00.000Z</published>
    <updated>2017-07-26T09:01:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚搭建了个博客,详情可以参照<a href="http://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="external">http://www.jianshu.com/p/4eaddcbe4d12</a><br>主要分三步来搭建:</p>
<h2 id="一-创建Github域名和控件"><a href="#一-创建Github域名和控件" class="headerlink" title="一: 创建Github域名和控件"></a>一: 创建Github域名和控件</h2><p>####1.1 注册<br>需要准备一个Github账号(不会的可以百度教程),需要注意的是username,这个名字将会是你的域名,像username.github.io.</p>
<p>####1.2 创建仓库<br>然后仓库(repository)来存储我们的网站,点击首页任意位置出现的New repository按钮创建仓库,Respository name中的username.github.io的username一定与前面的Owner一致,username在下面会用到. </p>
<h2 id="二-安装"><a href="#二-安装" class="headerlink" title="二: 安装"></a>二: 安装</h2><p>我们安装的是Hexo,基于Nodejs,是比较流行的博客框架,我们需要安装的工具都包括Hexo,Git,Nodejs.</p>
<h4 id="2-1-安装Git"><a href="#2-1-安装Git" class="headerlink" title="2.1 安装Git"></a>2.1 安装Git</h4><pre><code>// 如果已安装HomeBrew 无需执行此行
$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
$ brew install git   // 安装Git
</code></pre><h4 id="2-2-安装Nodejs"><a href="#2-2-安装Nodejs" class="headerlink" title="2.2 安装Nodejs"></a>2.2 安装Nodejs</h4><p>先安装nvm,这是Nodejs版本管理器,可以轻松切换Nodejs版本.可以参考前面的文章:</p>
<h4 id="2-3-安装Hexo"><a href="#2-3-安装Hexo" class="headerlink" title="2.3 安装Hexo"></a>2.3 安装Hexo</h4><p>打开终端,输入以下命令</p>
<pre><code>$ sudo npm install hexo-cli -g
</code></pre><p>所有工具安装完成后,就可以开始搭建博客了</p>
<h2 id="三-搭建"><a href="#三-搭建" class="headerlink" title="三: 搭建"></a>三: 搭建</h2><p>接下来我们用Hexo初始化一个博客,然后加上自己喜欢的主题,写上第一篇文章,然后发布到自己的个人Github网站(username.github.io).</p>
<h4 id="3-1-搭建博客"><a href="#3-1-搭建博客" class="headerlink" title="3.1 搭建博客"></a>3.1 搭建博客</h4><p>将下面的username替换成你自己的username(其实也无所谓),执行成功后,会创建出一个名为username.github.io的文件夹</p>
<pre><code>$ hexo init username.github.io
</code></pre><h4 id="3-2-安装主题"><a href="#3-2-安装主题" class="headerlink" title="3.2 安装主题"></a>3.2 安装主题</h4><p>作者用的是<a href="https://github.com/monniya/hexo-theme-new-vno" target="_blank" rel="external">喵神的主题</a>,<a href="https://hexo.io/themes/" target="_blank" rel="external">点击查看更多主题</a></p>
<p>在终端输入以下命令:</p>
<pre><code>$ cd username.github.io
$ git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><p>修改基础配置:<br>打开文件位置username.github.io/_config.yml修改几个键值对,下面把几个必须设置的列出来按需求修改,记得保存,还有注意配置的键值之间一定要有空格.<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">更多设置</a></p>
<blockquote>
<p>title: 刘子兴的博客 //博客名字<br>description: 正在潜心修行中 //描述<br>author: 刘子兴  //作者名字<br>language: zh-Hans  //语言<br>url: <a href="http://oneredfox.github.io">http://oneredfox.github.io</a>  //git链接<br>type: git  //发布类型<br>theme: next<br>repo: <a href="https://github.com/oneredfox/oneredfox.github.io.git" target="_blank" rel="external">https://github.com/oneredfox/oneredfox.github.io.git</a> //git链接            </p>
</blockquote>
<h2 id="四-写文章并发布"><a href="#四-写文章并发布" class="headerlink" title="四: 写文章并发布"></a>四: 写文章并发布</h2><h4 id="4-1写文章"><a href="#4-1写文章" class="headerlink" title="4.1写文章"></a>4.1写文章</h4><p>在username.github.io/source/_posts文件夹下创建一个.md文件,(用Macdown语言写)<br>写入以下代码:</p>
<pre><code>---
title: 刚刚搭建了个博客
date: 2013-02-11
tags: 三尾
---
今天天气很好
</code></pre><h4 id="4-1测试"><a href="#4-1测试" class="headerlink" title="4.1测试"></a>4.1测试</h4><pre><code>$ hexo s
</code></pre><p>你可以在浏览器中输入<a href="https://localhost:4000" target="_blank" rel="external">https://localhost:4000</a> 访问了,访问成功就说明OK了</p>
<h4 id="4-2hexo-deployer-git自动部署发布工具"><a href="#4-2hexo-deployer-git自动部署发布工具" class="headerlink" title="4.2hexo-deployer-git自动部署发布工具"></a>4.2hexo-deployer-git自动部署发布工具</h4><pre><code>$ npm install hexo-deployer-git --save
</code></pre><h4 id="4-3发布"><a href="#4-3发布" class="headerlink" title="4.3发布"></a>4.3发布</h4><pre><code>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d
</code></pre><p>在终端cd到username.github.io文件下,</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>里面的安装nvm有点问题,安装后总是提示  “command not found”,所以安装nvm和node不要按照那个,具体可以参考<a href="http://www.jianshu.com/p/a6044bd2ad35" target="_blank" rel="external">http://www.jianshu.com/p/a6044bd2ad35</a></p>
<p>安装的node版本:7.0</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚刚搭建了个博客,详情可以参照&lt;a href=&quot;http://www.jianshu.com/p/4eaddcbe4d12&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/4eaddcbe4d12&lt;/a&gt;&lt;b
    
    </summary>
    
    
      <category term="三尾" scheme="http://oneredfox.github.io/tags/%E4%B8%89%E5%B0%BE/"/>
    
  </entry>
  
</feed>
